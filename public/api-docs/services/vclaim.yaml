paths:
  # Endpoint untuk Create Signature
  /vclaim/auth/signature:
    get:
      tags: [VClaim]
      summary: Create Signature
      description: |
        ## Overview

        Secara umum, hampir setiap pemanggilan web-service, harus dicantumkan beberapa variabel yang dibutuhkan untuk menambahkan informasi ataupun untuk proses validasi yang dikirim pada HTTP Header, antara lain:

        | # | Nama Header | Nilai | Keterangan |
        |---|-------------|--------|------------|
        | 1 | X-cons-id | 743627386 | consumer ID dari BPJS Kesehatan |
        | 2 | X-timestamp | 234234234 | generated unix-based timestamp |
        | 3 | X-signature | DogC5UiQurNcigrBdQ3QN5oYvXeUF5E82I/LHUcI9v0= | generated signature dengan pola HMAC-256 |
        | 4 | user_key | d795b04f4a72d74fae727be9da0xxxxx | user_key untuk akses webservice |

        ### Penjelasan Header

        1. **X-cons-id**, merupakan kode consumer (pengakses web-service). Kode ini akan diberikan oleh BPJS Kesehatan.

        2. **X-timestamp**, merupakan waktu yang akan di-generate oleh client saat ingin memanggil setiap service. Format waktu ini ditulis dengan format unix-based-time (berisi angka, tidak dalam format tanggal sebagaimana mestinya). Format waktu menggunakan Coordinated Universal Time (UTC), dalam penggunaannya untuk mendapatkan timestamp, rumus yang digunakan adalah (local time in UTC timezone in seconds) - (1970-01-01 in seconds).

        3. **X-signature**, merupakan hasil dari pembuatan signature yang dibuat oleh client. Signature yang digunakan menggunakan pola HMAC-SHA256.

        4. **user_key**, merupakan key untuk mengakses webservice. Setiap service consumer memiliki user_key masing-masing.

        ### Consumer Information

        Untuk dapat mengakses web-service dari BPJS Kesehatan (service provider), pemanggil web service (service consumer) akan mendapatkan:
        - Consumer ID
        - Consumer Secret

        Informasi Consumer Secret, hanya disimpan oleh service consumer. Tidak dikirim ke server web-service, hal ini untuk menjaga pengamanan yang lebih baik. Sedangkan kebutuhan Consumer Secret ini adalah untuk men-generate Signature (X-signature).

        ### Contoh Pembuatan Signature

        **Contoh:**
        - consumerID : 1234
        - consumerSecret : pwd
        - timestamp : 433223232
        - variabel1 : consumerID&timestamp
        - variabel1 : 1234&433223232

        ### SIGNATURE

        Metode signature yang digunakan adalah menggunakan HMAC-SHA256, dimana parameter saat generate signature dibutuhkan parameter message dan key.

        **Contoh hasil generate HMAC-SHA256:**
        - message : aaa
        - key : bbb
        - hasil generate HMAC-SHA256 : 20BKS3PWnD3XU4JbSSZvVlGi2WWnDa8Sv9uHJ+wsELA=

        *Diatas adalah hasil generate dari server BPJS Kesehatan*

        **Formula:**
        - Signature : HMAC-256(value : key)
        - value : variabel1
        - key : consumerSecret
        - Signature : HMAC-256(variabel1 : consumerSecret)

        ## Contoh Pembuatan Signature

        ### JAVA
        ```java
        import java.io.ByteArrayOutputStream;
        import java.io.IOException;
        import java.io.UnsupportedEncodingException;
        import java.net.URLEncoder;
        import java.security.GeneralSecurityException;

        import javax.crypto.Mac;
        import javax.crypto.spec.SecretKeySpec;

        import org.springframework.security.crypto.codec.Base64;

        public class BpjsApi {

            public static void main(String[] args) throws GeneralSecurityException, IOException {

                String secretKey = "secretKey";
                String salt = "0123456789";

                String generateHmacSHA256Signature = generateHmacSHA256Signature(salt, secretKey);
                System.out.println("Signature: " + generateHmacSHA256Signature);

                String urlEncodedSign = URLEncoder.encode(generateHmacSHA256Signature, "UTF-8");

                System.out.println("Url encoded value: " + urlEncodedSign);
            }

            public static String generateHmacSHA256Signature(String data, String key) throws GeneralSecurityException {
                byte[] hmacData = null;

                try {
                    SecretKeySpec secretKey = new SecretKeySpec(key.getBytes("UTF-8"), "HmacSHA256");
                    Mac mac = Mac.getInstance("HmacSHA256");
                    mac.init(secretKey);
                    hmacData = mac.doFinal(data.getBytes("UTF-8"));
                    return new Base64Encoder().encode(hmacData);
                } catch (UnsupportedEncodingException e) {
                    throw new GeneralSecurityException(e);
                }
            }
        }
        ```

        ### PHP
        ```php
        <?php 
           $data = "testtesttest";
           $secretKey = "secretkey";
                 // Computes the timestamp
                  date_default_timezone_set('UTC');
                  $tStamp = strval(time()-strtotime('1970-01-01 00:00:00'));
                   // Computes the signature by hashing the salt with the secret key as the key
           $signature = hash_hmac('sha256', $data."&".$tStamp, $secretKey, true);
         
           // base64 encode…
           $encodedSignature = base64_encode($signature);
         
           // urlencode…
           // $encodedSignature = urlencode($encodedSignature);
         
           echo "X-cons-id: " .$data ." ";
           echo "X-timestamp:" .$tStamp ." ";
           echo "X-signature: " .$encodedSignature;
        ?>
        ```

        ### C#
        ```csharp
        namespace BpjsIntegration
        {
            class Program
            {
         
                static void Main()
                {
                    var data = "testtesttest";
                    var secretKey = "secretkey";
         
                    // Initialize the keyed hash object using the secret key as the key
                    HMACSHA256 hashObject = new HMACSHA256(Encoding.UTF8.GetBytes(secretKey));
         
                    // Computes the signature by hashing the salt with the secret key as the key
                    var signature = hashObject.ComputeHash(Encoding.UTF8.GetBytes(data));
         
                    // Base 64 Encode
                    var encodedSignature = Convert.ToBase64String(signature);
         
                    // URLEncode
                    // encodedSignature = System.Web.HttpUtility.UrlEncode(encodedSignature);
         
                    Console.WriteLine("Voila! A signature: " + encodedSignature);
         
                    Console.ReadKey();
         
                }
            }
        }
        ```

        ### VB.Net
        ```vb
        Imports System.Security.Cryptography
        Imports System.Text

        Namespace BpjsIntegration
            Class Program

                Private Shared Sub Main()
                    Dim data = "testtesttest"
                    Dim secretKey = "secretkey"

                    ' Initialize the keyed hash object using the secret key as the key
                    Dim hashObject As New HMACSHA256(Encoding.UTF8.GetBytes(secretKey))

                    ' Computes the signature by hashing the salt with the secret key as the key
                    Dim signature = hashObject.ComputeHash(Encoding.UTF8.GetBytes(data))

                    ' Base 64 Encode
                    Dim encodedSignature = Convert.ToBase64String(signature)

                    ' URLEncode
                    ' encodedSignature = System.Web.HttpUtility.UrlEncode(encodedSignature)

                    Console.WriteLine("Voila! A signature: " & encodedSignature)

                    Console.ReadKey()

                End Sub
            End Class
        End Namespace
        ```

        ### Ruby
        ```ruby
        # Required Libraries
        require 'openssl'
        require 'base64'
        require 'URI'
         
        data = "testtesttest"
        secret_key = "secretkey"
         
        # URL encode
        def urlncode(string)
        URI.escape(string, Regexp.new("[Generating an API Signature^#{URI::PATTERN::UNRESERVED}]"))
        end
         
        # Computes the signature by hashing the salt with the secret key as the key
        hash = OpenSSL::HMAC.digest('sha256', secret_key, data)
         
        # base64 encode...
        # signature = urlncode(Base64.encode64(hash));
        ```

        ### Python
        ```python
        import hashlib
        import random
        import base64
        import urllib
        import hmac
         
        data = "testtesttest"
        secretkey = "secretkey"
         
        # Computes the signature by hashing the data with the secret key as the key
        signature = hmac.new(secretkey, msg=data, digestmod=hashlib.sha256).digest()
         
        # base64 encode...
        encodedSignature = base64.encodestring(signature).replace('\n', '')
         
        # urlencode...
        # encodedSignature = urllib.quote(encodedSignature)
         
        print "Voila! A signature: " + encodedSignature
        ```

        ### Cocoa (iOS & Mac)
        ```objc
        -(NSUInteger)GenerateSalt
        {
            // random number (change the modulus to the length you'd like)
            NSUInteger r = arc4random() % 100000;
            return r;
        }
         
        -(NSString *)GenerateSignatureUsingSalt:(NSUInteger)salt
        {
            /*
             Make sure you import:
             */
         
            NSString *key = SECRET_KEY;                                            // define your Secret Key string
            NSString *data = [NSString stringWithFormat:"%u", salt];            // convert your random number
         
            const char *cKey  = [key cStringUsingEncoding:NSUTF8StringEncoding];
            const char *cData = [data cStringUsingEncoding:NSUTF8StringEncoding];
         
            unsigned char cHMAC[CC_SHA256_DIGEST_LENGTH];
         
            // Hash the salt with the secret key
            CCHmac(kCCHmacAlgSHA256, cKey, strlen(cKey), cData, strlen(cData), cHMAC);
         
            // Create a data structure
            NSData *HMAC = [[NSData alloc] initWithBytes:cHMAC
                                                  length:sizeof(cHMAC)];
         
            // Base64-encode the signature
            NSString *hash = [HMAC base64Encoding];
          
            return signatureURL;
         
        }
        ```
      parameters:
        - name: consumer_id
          in: query
          required: true
          schema:
            type: string
            example: "1234"
          description: Consumer ID yang diberikan oleh BPJS Kesehatan
        - name: timestamp
          in: query
          required: true
          schema:
            type: string
            example: "433223232"
          description: Unix-based timestamp dalam UTC
      responses:
        "200":
          description: Signature berhasil digenerate
          content:
            text/plain:
              schema:
                type: string
                example: "DogC5UiQurNcigrBdQ3QN5oYvXeUF5E82I/LHUcI9v0="
        "400":
          description: Parameter tidak valid
          content:
            application/json:
              schema:
                type: object
                properties:
                  error:
                    type: string
                    example: "Consumer ID dan timestamp wajib diisi"

  # Endpoint untuk How to Decrypt
  /vclaim/decrypt:
    post:
      tags: [VClaim]
      summary: How to Decrypt
      description: |
        ## Overview

        Response kembalian dari web service vclaim sudah dalam bentuk compress dan terenkripsi.

        **Kompresi service menggunakan metode:** Lz-string  
        **Enkripsi menggunakan metode:** AES 256 (mode CBC) - SHA256 dan key enkripsi: consid + conspwd + timestamp request (concatenate string)

        ### Langkah proses dalam melakukan decrypt data response sebagai berikut:
        1. **Dekripsi:** AES 256 (mode CBC) - SHA256
        2. **Dekompresi:** Lz-string (decompressFromEncodedURIComponent)

        **Key:** consid + conspwd + timestamp request (concatenate string)

        ## Contoh Penggunaan Decrypt Service

        ### JAVA
        ```java
        import java.nio.charset.StandardCharsets;
        import java.security.InvalidAlgorithmParameterException;
        import java.security.InvalidKeyException;
        import java.security.MessageDigest;
        import java.security.NoSuchAlgorithmException;
        import java.util.Base64;

        import javax.crypto.BadPaddingException;
        import javax.crypto.Cipher;
        import javax.crypto.IllegalBlockSizeException;
        import javax.crypto.NoSuchPaddingException;
        import javax.crypto.SecretKey;
        import javax.crypto.spec.IvParameterSpec;
        import javax.crypto.spec.SecretKeySpec;

        import id.go.bpjskesehatan.arsws.entitas.AesKeySpec;

        public class Enc {

            public static final String ALGORITHM = "AES/CBC/PKCS5Padding";

            public static AesKeySpec generateKey(String key) 
                    throws NoSuchPaddingException, NoSuchAlgorithmException,
                    InvalidAlgorithmParameterException, InvalidKeyException,
                    BadPaddingException, IllegalBlockSizeException {
                
                MessageDigest digest = MessageDigest.getInstance("SHA-256");
                byte[] _hashKey = digest.digest(key.getBytes(StandardCharsets.UTF_8));
                byte[] _hashIv = new byte[16];
                for (int i = 0; i < 16; i++) {
                    _hashIv[i] = _hashKey[i];
                }
            
                AesKeySpec aesKeySpec = new AesKeySpec();
                SecretKeySpec _key = new SecretKeySpec(_hashKey, "AES");
                IvParameterSpec _iv = new IvParameterSpec(_hashIv);
                aesKeySpec.setKey(_key);
                aesKeySpec.setIv(_iv);
                return aesKeySpec;
            }

            public static String decrypt(String cipherText, SecretKeySpec key, IvParameterSpec iv) 
                    throws NoSuchPaddingException, NoSuchAlgorithmException,
                    InvalidAlgorithmParameterException, InvalidKeyException,
                    BadPaddingException, IllegalBlockSizeException {
                
                Cipher cipher = Cipher.getInstance(ALGORITHM);
                cipher.init(Cipher.DECRYPT_MODE, key, iv);
                byte[] plainText = cipher.doFinal(Base64.getDecoder().decode(cipherText));
                return new String(plainText);
            }
            
            String respon = LZString.decompressFromEncodedURIComponent(lzString);
        }
        ```

        ### PHP
        ```php
        <?php 
            require_once 'vendor/autoload.php';

            // function decrypt
            function stringDecrypt($key, $string){
                
          
                $encrypt_method = 'AES-256-CBC';

                // hash
                $key_hash = hex2bin(hash('sha256', $key));
          
                // iv - encrypt method AES-256-CBC expects 16 bytes - else you will get a warning
                $iv = substr(hex2bin(hash('sha256', $key)), 0, 16);

                $output = openssl_decrypt(base64_decode($string), $encrypt_method, $key_hash, OPENSSL_RAW_DATA, $iv);
          
                return $output;
            }

            // function lzstring decompress 
            // download libraries lzstring : https://github.com/nullpunkt/lz-string-php
            function decompress($string){
          
                return \LZCompressor\LZString::decompressFromEncodedURIComponent($string);

            }
        ?>
        ```

        ### C#
        ```csharp
        namespace BpjsIntegration
        {
            class Program
            {
         
                public string Decrypt(string key, string data)
                {
                    string decData = null;
                    byte[][] keys = GetHashKeys(key);

                    try
                    {
                        decData = DecryptStringFromBytes_Aes(data, keys[0], keys[1]);
                    }
                    catch (CryptographicException) { }
                    catch (ArgumentNullException) { }

                    return decData;
                }

                private static string DecryptStringFromBytes_Aes(string cipherTextString, byte[] Key, byte[] IV)
                {
                    byte[] cipherText = Convert.FromBase64String(cipherTextString);

                    if (cipherText == null || cipherText.Length <= 0)
                        throw new ArgumentNullException("cipherText");
                    if (Key == null || Key.Length <= 0)
                        throw new ArgumentNullException("Key");
                    if (IV == null || IV.Length <= 0)
                        throw new ArgumentNullException("IV");

                    string plaintext = null;

                    using (Aes aesAlg = Aes.Create())
                    {
                        aesAlg.Key = Key;
                        aesAlg.IV = IV;

                        ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

                        using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                        {
                            using (CryptoStream csDecrypt =
                                    new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                            {
                                using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                                {
                                    plaintext = srDecrypt.ReadToEnd();
                                }
                            }
                        }
                    }
                    return plaintext;
                }

            private byte[][] GetHashKeys(string key)
            //public byte[][] GetHashKeys(string key)
            {
                byte[][] result = new byte[2][];
                Encoding enc = Encoding.UTF8;

                SHA256 sha2 = new SHA256CryptoServiceProvider();

                byte[] rawKey = enc.GetBytes(key);
                byte[] rawIV = enc.GetBytes(key);

                byte[] hashKey = sha2.ComputeHash(rawKey);
                byte[] hashIV = sha2.ComputeHash(rawIV);

                Array.Resize(ref hashIV, 16);

                result[0] = hashKey;
                result[1] = hashIV;

                return result;
            }

                ///Decrypted
                string LZDecrypted = _security.Decrypt(key, textenc);
                string result = LZString.decompressFromEncodedURIComponent(LZDecrypted);   

            }   
        }

        //source: https://msdn.microsoft.com/de-de/library/system.security.cryptography.aes(v=vs.110).aspx
        ```

        ### Python
        ```python
        import hashlib
        from Crypto.Cipher import AES
        from Crypto.Util.Padding import pad, unpad
        import base64
        import lzstring


        def decrypt(key, txt_enc):

            x = lzstring.LZString()

            key_hash = hashlib.sha256(key.encode('utf-8')).digest()

            mode = AES.MODE_CBC

            # decrypt
            decryptor = AES.new(key_hash[0:32], mode, IV=key_hash[0:16])
            plain = decryptor.decrypt(base64.b64decode(txt_enc))
            decompress = x.decompressFromEncodedURIComponent(plain.decode('utf-8'))

            return decompress
        ```
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - encrypted_data
                - consid
                - conspwd
                - timestamp
              properties:
                encrypted_data:
                  type: string
                  description: Data terenkripsi dari VClaim dalam format base64
                  example: "U2FsdGVkX1/6lDpQ7KJZ5r4sD3a2+4xHQ=="
                consid:
                  type: string
                  description: Consumer ID
                  example: "12345"
                conspwd:
                  type: string
                  description: Consumer Secret/Password
                  example: "password_rahasia"
                timestamp:
                  type: string
                  description: Timestamp yang digunakan saat request (concatenate dengan consid + conspwd)
                  example: "433223232"
      responses:
        "200":
          description: Data berhasil didekripsi
          content:
            application/json:
              schema:
                type: object
                properties:
                  decrypted_data:
                    type: string
                    description: Data hasil dekripsi dalam format JSON
                    example: '{"metadata": {"code": 1, "message": "OK"}, "response": {"peserta": {...}}}'
        "400":
          description: Parameter tidak valid atau dekripsi gagal
          content:
            application/json:
              schema:
                type: object
                properties:
                  error:
                    type: string
                    example: "Gagal mendekripsi data. Periksa parameter input."
        "500":
          description: Internal server error
          content:
            application/json:
              schema:
                type: object
                properties:
                  error:
                    type: string
                    example: "Terjadi kesalahan dalam proses dekripsi"
